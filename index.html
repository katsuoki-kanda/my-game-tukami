<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking Game - Smart Recognition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        video { transform: scaleX(-1); display: none; }
        canvas { transform: scaleX(-1); width: 100%; height: 100%; object-fit: contain; }
        
        #ui {
            position: absolute; top: 20px; left: 20px; color: #0f0; font-size: 32px;
            pointer-events: none; text-shadow: 2px 2px 4px #000; z-index: 20;
        }
        #score, #timer { margin-bottom: 10px; }
        
        #message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff0; font-size: 32px; text-align: center; pointer-events: none;
            background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px;
            z-index: 10;
        }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>
    <div id="ui">
        <div id="score">Score: 0</div>
        <div id="timer">Time: 60</div>
    </div>
    <div id="message">カメラ起動中...</div>
</div>

<script>
const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const canvasCtx = canvasElement.getContext('2d');
const scoreElement = document.getElementById('score');
const timerElement = document.getElementById('timer');
const messageElement = document.getElementById('message');

let score = 0;
let gameStarted = false;
let startTime = 0;
let lastEndTime = 0;
const cooldownTime = 3000; 
const gameDuration = 60;

let circle = { x: 0, y: 0, radius: 50 }; 
const ringRadius = 60;

let isReadyToCatch = false;
let handStates = [
    { isTouching: false, wasBent: true },
    { isTouching: false, wasBent: true }
];

const synth = window.speechSynthesis;
function speak(text) {
    try {
        synth.cancel();
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = 'ja-JP';
        synth.speak(utter);
    } catch (e) {}
}

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playCatchSound() {
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(700, audioCtx.currentTime);
    osc.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
}

function generateNewCircle() {
    circle.x = Math.random() * (canvasElement.width - 200) + 100;
    const minY = 150;
    const maxY = (canvasElement.height * (7 / 8)) - circle.radius;
    circle.y = Math.random() * (maxY - minY) + minY;
    
    handStates.forEach(s => s.isTouching = false);
    isReadyToCatch = false;
}

// 2点間の距離を計算する関数
function getDistance(p1, p2) {
    return Math.hypot(p1.x - p2.x, p1.y - p2.y);
}

function onResults(results) {
    canvasElement.width = videoElement.videoWidth;
    canvasElement.height = videoElement.videoHeight;

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

    let targetCaught = false;
    let currentFrameReadyToCatch = false;
    const now = Date.now();

    if (results.multiHandLandmarks && !gameStarted && (now - lastEndTime > cooldownTime)) {
        if (messageElement.innerText === "カメラ起動中...") {
            messageElement.innerHTML = "START --- hand up<br><small>(どちらかの手を高く上げてください)</small>";
        }
    }

    if (results.multiHandLandmarks) {
        results.multiHandLandmarks.forEach((landmarks, index) => {
            if (index > 1) return;

            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 3});
            
            const wrist = landmarks[0];     // 手首
            const middleBase = landmarks[9]; // 中指付け根(MCP)
            const middleTip = landmarks[12]; // 中指先端(TIP)
            
            const hx = middleBase.x * canvasElement.width;
            const hy = middleBase.y * canvasElement.height;

            // --- 判定ロジックの改善 ---
            const palmSize = getDistance(wrist, middleBase);
            const fingerLength = getDistance(middleBase, middleTip);
            
            // 指が曲がっているかどうかの判定
            const isBentNow = fingerLength < (palmSize * 0.6); 

            // リングの描画
            canvasCtx.beginPath();
            canvasCtx.arc(hx, hy, ringRadius, 0, 2 * Math.PI);
            
            // 修正箇所：指が曲がっている時は白、それ以外は黄色
            canvasCtx.strokeStyle = isBentNow ? '#FFF' : '#FF0'; 
            // 修正箇所：線の太さを1.5倍（4 -> 6）に変更
            canvasCtx.lineWidth = 6;
            
            canvasCtx.stroke();

            if (!gameStarted) {
                if (now - lastEndTime > cooldownTime) {
                    if (messageElement.innerText.includes("終了")) {
                        messageElement.innerHTML = "START --- hand up<br><small>(どちらかの手を高く上げてください)</small>";
                    }
                    if (middleBase.y < 0.4) {
                        gameStarted = true;
                        score = 0;
                        startTime = now;
                        messageElement.style.display = 'none';
                        speak("スタート");
                        generateNewCircle();
                    }
                }
            } else {
                const dist = Math.hypot(hx - circle.x, hy - circle.y);
                const isTouchingNow = dist < ringRadius;

                if (isTouchingNow && !isBentNow) {
                    currentFrameReadyToCatch = true;
                }

                if (isTouchingNow && !handStates[index].wasBent && isBentNow) {
                    targetCaught = true;
                }

                handStates[index].isTouching = isTouchingNow;
                handStates[index].wasBent = isBentNow;
            }
        });
    }

    isReadyToCatch = currentFrameReadyToCatch;

    if (gameStarted) {
        if (targetCaught) {
            playCatchSound();
            score++;
            generateNewCircle();
        }

        const elapsed = Math.floor((now - startTime) / 1000);
        const remaining = Math.max(0, gameDuration - elapsed);
        
        timerElement.innerText = `Time: ${remaining}`;
        scoreElement.innerText = `Score: ${score}`;

        canvasCtx.save();
        if (isReadyToCatch) {
            canvasCtx.shadowBlur = 35;
            canvasCtx.shadowColor = "red";
            canvasCtx.fillStyle = 'red';
        } else {
            canvasCtx.fillStyle = 'green';
        }
        
        canvasCtx.beginPath();
        canvasCtx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
        canvasCtx.fill();
        canvasCtx.restore();

        if (remaining <= 0) {
            gameStarted = false;
            lastEndTime = now;
            messageElement.style.display = 'block';
            messageElement.innerHTML = `終了！<br>${score}点です`;
            speak(`${score}点です。終了。`);
        }
    }
    canvasCtx.restore();
}

const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
    maxNumHands: 2,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});
hands.onResults(onResults);

const camera = new Camera(videoElement, {
    onFrame: async () => {
        await hands.send({image: videoElement});
    },
    width: 1280,
    height: 720
});

window.onload = () => {
    camera.start();
};

document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' || e.key === 'q') {
        speak("やめます");
        gameStarted = false;
        lastEndTime = Date.now();
        messageElement.style.display = 'block';
        messageElement.innerText = '中断しました。リロードして下さい。';
    }
});
</script>

</body>
</html>